import{p as x,O as A,R as M,E as j,j as F,b as E,g as O,y as R,x as S,v as _,w as T,_ as z,q,$ as N,m as k,a as C,A as P,h as Y,d as B,c as G,e as H,N as I,f as J,i as K,k as L,l as Q,z as U,n as V,o as W}from"./@ucast-C1jhqbEt.js";function d(e){return Array.isArray(e)?e:[e]}const p="__caslSubjectType__",u=e=>{const t=typeof e;return t==="string"||t==="function"},X=e=>e.modelName||e.name;function b(e){return Object.hasOwn(e,p)?e[p]:X(e.constructor)}const g={function:e=>e.constructor,string:b};function y(e,t,s){for(let n=s;n<t.length;n++)e.push(t[n])}function $(e,t){if(!e||!e.length)return t||[];if(!t||!t.length)return e||[];let s=0,n=0;const i=[];for(;s<e.length&&n<t.length;)e[s].priority<t[n].priority?(i.push(e[s]),s++):(i.push(t[n]),n++);return y(i,e,s),y(i,t,n),i}function a(e,t,s){let n=e.get(t);return n||(n=s(),e.set(t,n)),n}const Z=e=>e;function D(e,t){if(Array.isArray(e.fields)&&!e.fields.length)throw new Error("`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa");if(e.fields&&!t.fieldMatcher)throw new Error('You need to pass "fieldMatcher" option in order to restrict access by fields');if(e.conditions&&!t.conditionsMatcher)throw new Error('You need to pass "conditionsMatcher" option in order to restrict access by conditions')}class tt{constructor(t,s,n=0){D(t,s),this.action=s.resolveAction(t.action),this.subject=t.subject,this.inverted=!!t.inverted,this.conditions=t.conditions,this.reason=t.reason,this.origin=t,this.fields=t.fields?d(t.fields):void 0,this.priority=n,this.t=s}i(){return this.conditions&&!this.o&&(this.o=this.t.conditionsMatcher(this.conditions)),this.o}get ast(){const t=this.i();return t?t.ast:void 0}matchesConditions(t){return this.conditions?!t||u(t)?!this.inverted:this.i()(t):!0}matchesField(t){return this.fields?t?(this.u||(this.u=this.t.fieldMatcher(this.fields)),this.u(t)):!this.inverted:!0}}function et(e,t){const s={value:e,prev:t,next:null};return t&&(t.next=s),s}function st(e){e.next&&(e.next.prev=e.prev),e.prev&&(e.prev.next=e.next),e.next=e.prev=null}const nt=e=>({value:e.value,prev:e.prev,next:e.next}),v=()=>({rules:[],merged:!1}),m=()=>new Map;class it{constructor(t=[],s={}){this.h=!1,this.l=new Map,this.p={conditionsMatcher:s.conditionsMatcher,fieldMatcher:s.fieldMatcher,resolveAction:s.resolveAction||Z},this.$=s.anyAction||"manage",this.A=s.anySubjectType||"all",this.m=t,this.M=!!s.detectSubjectType,this.j=s.detectSubjectType||b,this.v(t)}get rules(){return this.m}detectSubjectType(t){return u(t)?t:t?this.j(t):this.A}update(t){const s={rules:t,ability:this,target:this};return this._("update",s),this.m=t,this.v(t),this._("updated",s),this}v(t){const s=new Map;let n;for(let i=t.length-1;i>=0;i--){const r=t.length-i-1,o=new tt(t[i],this.p,r),l=d(o.action),h=d(o.subject||this.A);!this.h&&o.fields&&(this.h=!0);for(let c=0;c<h.length;c++){const w=a(s,h[c],m);n===void 0&&(n=typeof h[c]),typeof h[c]!==n&&n!=="mixed"&&(n="mixed");for(let f=0;f<l.length;f++)a(w,l[f],v).rules.push(o)}}if(this.l=s,n!=="mixed"&&!this.M){const i=g[n]||g.string;this.j=i}}possibleRulesFor(t,s=this.A){if(!u(s))throw new Error('"possibleRulesFor" accepts only subject types (i.e., string or class) as the 2nd parameter');const n=a(this.l,s,m),i=a(n,t,v);if(i.merged)return i.rules;const r=t!==this.$&&n.has(this.$)?n.get(this.$).rules:void 0;let o=$(i.rules,r);return s!==this.A&&(o=$(o,this.possibleRulesFor(t,this.A))),i.rules=o,i.merged=!0,o}rulesFor(t,s,n){const i=this.possibleRulesFor(t,s);if(n&&typeof n!="string")throw new Error("The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details");return this.h?i.filter(r=>r.matchesField(n)):i}actionsFor(t){if(!u(t))throw new Error('"actionsFor" accepts only subject types (i.e., string or class) as a parameter');const s=new Set,n=this.l.get(t);n&&Array.from(n.keys()).forEach(r=>s.add(r));const i=t!==this.A?this.l.get(this.A):void 0;return i&&Array.from(i.keys()).forEach(r=>s.add(r)),Array.from(s)}on(t,s){this.F=this.F||new Map;const n=this.F,i=n.get(t)||null,r=et(s,i);return n.set(t,r),()=>{const o=n.get(t);!r.next&&!r.prev&&o===r?n.delete(t):r===o&&n.set(t,r.prev),st(r)}}_(t,s){if(!this.F)return;let n=this.F.get(t)||null;for(;n!==null;){const i=n.prev?nt(n.prev):null;n.value(s),n=i}}}class rt extends it{can(t,s,n){const i=this.relevantRuleFor(t,s,n);return!!i&&!i.inverted}relevantRuleFor(t,s,n){const i=this.detectSubjectType(s),r=this.rulesFor(t,i,n);for(let o=0,l=r.length;o<l;o++)if(r[o].matchesConditions(s))return r[o];return null}cannot(t,s,n){return!this.can(t,s,n)}}const ot={$eq:A,$ne:M,$lt:j,$lte:F,$gt:E,$gte:O,$in:R,$nin:S,$all:_,$size:T,$regex:z,$options:q,$elemMatch:N,$exists:k},ct={eq:C,ne:P,lt:Y,lte:B,gt:G,gte:H,in:I,nin:J,all:K,size:L,regex:Q,elemMatch:U,exists:V,and:W},lt=x(ot,ct),ht=/[-/\\^$+?.()|[\]{}]/g,at=/\.?\*+\.?/g,ut=/\*+/,ft=/\./g;function dt(e,t,s){const n=s[0]==="*"||e[0]==="."&&e[e.length-1]==="."?"+":"*",i=e.indexOf("**")===-1?"[^.]":".",r=e.replace(ft,"\\$&").replace(ut,i+n);return t+e.length===s.length?`(?:${r})?`:r}function pt(e,t,s){return e==="."&&(s[t-1]==="*"||s[t+1]==="*")?e:`\\${e}`}function gt(e){const t=e.map(n=>n.replace(ht,pt).replace(at,dt)),s=t.length>1?`(?:${t.join("|")})`:t[0];return new RegExp(`^${s}$`)}const yt=e=>{let t;return s=>(typeof t>"u"&&(t=e.every(n=>n.indexOf("*")===-1)?null:gt(e)),t===null?e.indexOf(s)!==-1:t.test(s))};function vt(e=[],t={}){return new rt(e,Object.assign({conditionsMatcher:lt,fieldMatcher:yt},t))}export{vt as c};
